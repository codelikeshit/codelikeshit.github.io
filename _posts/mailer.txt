* Action Mailer yo its awesome it makes the job of sending email pretty easy but its tricky as well:).

* One day I was writing some code for sending email and a bulb all of sudden blinked over my head.

---Mailer class code-----
class MyAwesomeMailer < ActionMailer::Base

  def send_email(_user, _message)
    @user    = _user
    @message = _message
  end

end

---Model class code-----
class User < ActiveRecord::Base

  after_commit :notify_user, on: :create

  def notify_user
    MyAwesomeMailer.send_email(self, "Welcome to Interakt.co")
  end
end

* Have a look in the code the send_email is instance method but in model class I called a class method.

* I used to define instance methods in my mailers but what I am calling are class methods, I was shocked and asked from couple of my senior but didn't get answer, some of them tried to guess and said it might be using method missing hook of Ruby so finally decided to browse the source code myself.


* Browsing source code:-

    * Once I decided to open the code base I jumped directly into https://github.com/rails/rails/blob/master/actionmailer/lib/action_mailer/base.rb file and started reading it.

    * First thing I tried while doing this is calling it like a instance method but it didn't work, go and try it you will get the same exception.

    ----------------
    MyAwesomeMailer.new.send_email(User.last, "Welcome to Interakt.co")
    ----------------

    It didn't work and recieved an error private method new :(.

    * First thing that I thought about was new is a class method and if I use private or protected it will not work for class methods.

    * I got a new method private_class_method :new it mark methods as private.

    * Coming back to our main stuff, I tried and got the answer and that is its basically using method_missing hook of ruby and doing the stuff in backend.


    * What it does is basically it is overriding method missing hook of ruby and creating new instance of the mailer and running method on it.

    * Expaining in coding way:-

    This is the method missing code of ActionMailer::Base:-

    class Base < AbstractController::Base

      class << self

        def method_missing(method_name, *args) # :nodoc:
          if action_methods.include?(method_name.to_s)
            MessageDelivery.new(self, method_name, *args)
          else
            super
          end
        end

      end

    end


      e.g I called MyAwesomeMailer.send_email(User.last, "Welcome to Interakt.co").deliver_now

      This will catch and expception and create a new instance of MessageDelivery have a look at MessageDelivery class:-


      class MessageDelivery < Delegator

        def initialize(mailer, mail_method, *args) #:nodoc:
          @mailer = mailer
          @mail_method = mail_method
          @args = args
        end

        def __getobj__ #:nodoc:
          @obj ||= @mailer.send(:new, @mail_method, *@args).message
        end

        # Returns the Mail::Message object
        def message
          __getobj__
        end

        def deliver_now
          message.deliver
        end
      end

      * During initialization you setup all the variable and then you call deliver_now method on it.

      * Have a look at it and message is calling __getobj__ which is calling

      @mailer.send(:new, @mail_method, *@args).message

      this is changing the game, so I decided to try it in console as well and it worked like charm:-

      MyAwesomeMailer.send (:new, :send_email, User.last, "Welcome to Interakt.co").deliver


      def deliver_now
        message.deliver
      end

      * Then deliver is called on resulting object.

      * this is the basic cycle of mailer and
